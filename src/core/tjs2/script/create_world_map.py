import os
import re
import sys


# 按字典顺序排序单词，构造switch语句树
def gen(level, word_list) -> str:
    padding = " " * (level * 4)
    names = sorted(word_list.keys())

    if len(names) == 1 and names[0] == "\b":
        # 只有一个选择，且在末端
        v, tok = word_list["\b"].split("\t")
        return (f"{padding}if(!TJS_iswalpha(InputPointer[{level}])){{\n"
                f"{padding}InputPointer += {level}; yylex->val = {v}; return {tok};\n"
                f"{padding}}}\n")

    # 获取第一个字符
    fc = ''
    new_list = {}
    cnt = 0
    ret = ''

    ret += f"{padding}switch(InputPointer[{level}])\n"
    ret += f"{padding}{{\n"

    caselist = ''
    deflist = ''

    for name in names:
        nfc = name[0]
        if fc != nfc:
            if cnt:
                if fc == "\b":
                    # 末端
                    deflist += f"{padding}default:\n"
                    v, tok = word_list["\b"].split("\t")
                    deflist += (f"{padding}if(!TJS_iswalpha(InputPointer[{level}])){{\n"
                                f"{padding}InputPointer += {level}; yylex->val = {v}; return {tok};\n"
                                f"{padding}}}\n")
                else:
                    caselist += f"{padding}case TJS_W('{fc}'):\n"
                    if re.match(r'[a-z]', fc):
                        caselist += f"{padding}case TJS_W('{fc.upper()}'):\n"
                    caselist += gen(level + 1, new_list)
                    caselist += f"{padding}    break;\n"
            fc = nfc
            new_list = {}
            cnt = 0
        new_list[name[1:]] = word_list[name]
        cnt += 1

    if cnt:
        if fc == "\b":
            # 末端
            deflist += f"{padding}default:\n"
            v, tok = word_list["\b"].split("\t")
            deflist += f"{padding}    InputPointer += {level}; yylex->val = {v}; return {tok};\n"
        else:
            caselist += f"{padding}case TJS_W('{fc}'):\n"
            if re.match(r'[a-z]', fc):
                caselist += f"{padding}case TJS_W('{fc.upper()}'):\n"
            caselist += gen(level + 1, new_list)
            caselist += f"{padding}    break;\n"

    return ret + caselist + deflist + f"{padding}}}\n"


if __name__ == "__main__":
    filepath = sys.argv[1]
    if not sys.argv[1]:
        print(f"error command expect: python {os.path.basename(__file__)} <filename>")
        exit()
    if os.path.exists(filepath):
        os.remove(filepath)
    if not os.path.exists(os.path.dirname(filepath)):
        os.mkdir(os.path.dirname(filepath))
    print(f"create file: {filepath}")

    # 读取单词文件
    with open("./dp_word_table.txt", 'r') as f:
        lines = f.readlines()

    words = {}

    for line in lines:
        line = line.strip()
        match = re.match(r'^\s*(.*?)\s+(.*?)\s+(.*)', line)
        if match:
            words[match.group(1) + "\b"] = match.group(2) + "\t" + match.group(3)

    with open(filepath, 'w') as f:
        f.write(f"""/*
        Date/time string parser lexical analyzer word cutter.

        This file is always generated by
        {os.path.basename(__file__)}.
        Modification by hand will be lost.\n*/\n""")

        f.write(gen(0, words))